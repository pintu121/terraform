---
page_title: Standard Module Structure
description: >-
  Learn about the recommended file and directory structure for developing reusable modules distributed as separate repositories.
---

# Standard Module Structure

The standard module structure is a file and directory layout we recommend for
reusable modules distributed in separate repositories. Terraform tooling is
built to understand the standard module structure and use that structure to
generate documentation, index modules for the module registry, and more.

The standard module structure expects the layout documented below. The list may
appear long, but everything is optional except for the root module. Most modules
don't need to do any extra work to follow the standard structure.

* **Root module**. This is the **only required element** for the standard
  module structure. Terraform files must exist in the root directory of
  the repository. This should be the primary entrypoint for the module and is
  expected to be opinionated. For the
  [Consul module](https://registry.terraform.io/modules/hashicorp/consul)
  the root module sets up a complete Consul cluster. It makes a lot of assumptions
  however, and we expect that advanced users will use specific _nested modules_
  to more carefully control what they want.

* **README**. The root module and any nested modules should have README
  files. This file should be named `README` or `README.md`. The latter will
  be treated as markdown. There should be a description of the module and
  what it should be used for. If you want to include an example for how this
  module can be used in combination with other resources, put it in an [examples
  directory like this](https://github.com/hashicorp/terraform-aws-consul/tree/master/examples).
  Consider including a visual diagram depicting the infrastructure resources
  the module may create and their relationship.

  The README doesn't need to document inputs or outputs of the module because
  tooling will automatically generate this. If you are linking to a file or
  embedding an image contained in the repository itself, use a commit-specific
  absolute URL so the link won't point to the wrong version of a resource in the
  future.

* **LICENSE**. The license under which this module is available. If you are
  publishing a module publicly, many organizations will not adopt a module
  unless a clear license is present. We recommend always having a license
  file, even if it is not an open source license.

* **`main.tf`, `variables.tf`, `outputs.tf`**. These are the recommended filenames for
  a minimal module, even if they're empty. `main.tf` should be the primary
  entrypoint. For a simple module, this may be where all the resources are
  created. For a complex module, resource creation may be split into multiple
  files but any nested module calls should be in the main file. `variables.tf`
  and `outputs.tf` should contain the declarations for variables and outputs,
  respectively.

* **Variables and outputs should have descriptions.** All variables and
  outputs should have one or two sentence descriptions that explain their
  purpose. This is used for documentation. See the documentation for
  [variable configuration](/terraform/language/values/variables) and
  [output configuration](/terraform/language/values/outputs) for more details.

* **Nested modules**. Nested modules should exist under the `modules/`
  subdirectory. Any nested module with a `README.md` is considered usable
  by an external user. If a README doesn't exist, it is considered for internal
  use only. These are purely advisory; Terraform will not actively deny usage
  of internal modules. Nested modules should be used to split complex behavior
  into multiple small modules that advanced users can carefully pick and
  choose. For example, the
  [Consul module](https://registry.terraform.io/modules/hashicorp/consul)
  has a nested module for creating the Cluster that is separate from the
  module to setup necessary IAM policies. This allows a user to bring in their
  own IAM policy choices.

  If the root module includes calls to nested modules, they should use relative
  paths like `./modules/consul-cluster` so that Terraform will consider them
  to be part of the same repository or package, rather than downloading them
  again separately.

  If a repository or package contains multiple nested modules, they should
  ideally be [composable](/terraform/language/modules/develop/composition) by the caller, rather than
  calling directly to each other and creating a deeply-nested tree of modules.

* **Examples**. Examples of using the module should exist under the
  `examples/` subdirectory at the root of the repository. Each example may have
  a README to explain the goal and usage of the example. Examples for
  submodules should also be placed in the root `examples/` directory.

  Because examples will often be copied into other repositories for
  customization, any `module` blocks should have their `source` set to the
  address an external caller would use, not to a relative path.

A minimal recommended module following the standard structure is shown below.
While the root module is the only required element, we recommend the structure
below as the minimum:

```sh
$ tree minimal-module/
.
├── README.md
├── main.tf
├── variables.tf
├── outputs.tf
```

A complete example of a module following the standard structure is shown below.
This example includes all optional elements and is therefore the most
complex a module can become:

```sh
$ tree complete-module/
.
├── README.md
├── main.tf
├── variables.tf
├── outputs.tf
├── ...
├── modules/
│   ├── nestedA/
│   │   ├── README.md
│   │   ├── variables.tf
│   │   ├── main.tf
│   │   ├── outputs.tf
│   ├── nestedB/
│   ├── .../
├── examples/
│   ├── exampleA/
│   │   ├── main.tf
│   ├── exampleB/
│   ├── .../
```
An Enterprise-Level Terraform project typically involves complex, multi-environment setups with a focus on best practices for security, scalability, and maintainability. Here’s a comprehensive structure reflecting such an environment:

### Enterprise-Level Terraform Project Structure

```
terraform-project/
│
├── modules/                  # Reusable Terraform modules
│   ├── network/              # Network infrastructure module
│   │   ├── main.tf
│   │   ├── variables.tf
│   │   ├── outputs.tf
│   │   ├── README.md
│   │   └── tests/            # Unit tests for the module
│   │       └── test_main.tf
│   ├── compute/              # Compute resources module
│   │   ├── main.tf
│   │   ├── variables.tf
│   │   ├── outputs.tf
│   │   ├── README.md
│   │   └── tests/            # Unit tests for the module
│   │       └── test_main.tf
│   ├── storage/              # Storage resources module
│   │   ├── main.tf
│   │   ├── variables.tf
│   │   ├── outputs.tf
│   │   ├── README.md
│   │   └── tests/            # Unit tests for the module
│   │       └── test_main.tf
│   ├── security/             # Security policies module
│   │   ├── main.tf
│   │   ├── variables.tf
│   │   ├── outputs.tf
│   │   ├── README.md
│   │   └── tests/            # Unit tests for the module
│   │       └── test_main.tf
│   ├── monitoring/           # Monitoring module
│   │   ├── main.tf
│   │   ├── variables.tf
│   │   ├── outputs.tf
│   │   ├── README.md
│   │   └── tests/            # Unit tests for the module
│   │       └── test_main.tf
│   ├── application/          # Application deployment module
│   │   ├── main.tf
│   │   ├── variables.tf
│   │   ├── outputs.tf
│   │   ├── README.md
│   │   └── tests/            # Unit tests for the module
│   │       └── test_main.tf
│   └── multi-cloud/          # Multi-cloud modules (e.g., AWS, Azure, GCP)
│       ├── aws/              # AWS-specific resources
│       │   ├── main.tf
│       │   ├── variables.tf
│       │   ├── outputs.tf
│       │   ├── README.md
│       │   └── tests/
│       │       └── test_main.tf
│       ├── azure/            # Azure-specific resources
│       │   ├── main.tf
│       │   ├── variables.tf
│       │   ├── outputs.tf
│       │   ├── README.md
│       │   └── tests/
│       │       └── test_main.tf
│       └── gcp/              # GCP-specific resources
│           ├── main.tf
│           ├── variables.tf
│           ├── outputs.tf
│           ├── README.md
│           └── tests/
│               └── test_main.tf
│
├── environments/             # Environment-specific configurations
│   ├── dev/                  # Development environment
│   │   ├── main.tf
│   │   ├── variables.tf
│   │   ├── outputs.tf
│   │   ├── terraform.tfvars
│   │   ├── provider.tf
│   │   ├── backend.tf
│   │   ├── iam.tf
│   │   ├── networking.tf
│   │   ├── security.tf
│   │   ├── monitoring.tf
│   │   ├── multi-cloud.tf    # Multi-cloud configurations for dev environment
│   │   └── README.md
│   ├── staging/              # Staging environment
│   │   ├── main.tf
│   │   ├── variables.tf
│   │   ├── outputs.tf
│   │   ├── terraform.tfvars
│   │   ├── provider.tf
│   │   ├── backend.tf
│   │   ├── iam.tf
│   │   ├── networking.tf
│   │   ├── security.tf
│   │   ├── monitoring.tf
│   │   ├── multi-cloud.tf
│   │   └── README.md
│   └── production/           # Production environment
│       ├── main.tf
│       ├── variables.tf
│       ├── outputs.tf
│       ├── terraform.tfvars
│       ├── provider.tf
│       ├── backend.tf
│       ├── iam.tf
│       ├── networking.tf
│       ├── security.tf
│       ├── monitoring.tf
│       ├── multi-cloud.tf
│       └── README.md
│
├── terraform/                # Terraform-specific configurations
│   ├── provider.tf           # Provider configurations
│   ├── backend.tf            # Backend configuration
│   ├── variables.tf          # Global variables
│   ├── outputs.tf            # Global outputs
│   ├── main.tf               # Root module with resources
│   ├── terraform.tfstate     # State file (if local)
│   ├── terraform.tfstate.backup # Backup of the state file (if local)
│   └── README.md             # Documentation on Terraform setup
│
├── scripts/                  # Auxiliary scripts for automation
│   ├── setup.sh              # Example setup script
│   ├── deploy.sh             # Example deployment script
│   ├── cleanup.sh            # Example cleanup script
│   ├── validate.sh           # Script for validating configurations
│   ├── plan.sh               # Script for creating and reviewing plans
│   ├── apply.sh              # Script for applying Terraform changes
│   ├── rotate-keys.sh        # Script for rotating access keys and secrets
│   ├── backup.sh             # Script for backing up state files
│   └── upgrade.sh            # Script for upgrading Terraform versions
│
├── tools/                    # Tools and integrations
│   ├── terraform-lint/       # Configuration for linting Terraform code
│   │   ├── .terrafmt.yml
│   │   └── .terralinter.yml
│   ├── security-scanner/     # Configuration for security scanning tools
│   │   ├── checkov.yml
│   │   └── snyk.yml
│   ├── ci-cd/                # CI/CD pipeline configurations
│   │   ├── Jenkinsfile       # Jenkins pipeline configuration
│   │   ├── .gitlab-ci.yml    # GitLab CI/CD configuration
│   │   └── .github/workflows/ # GitHub Actions workflows
│   │       └── terraform.yml
│   └── compliance/           # Compliance automation tools
│       ├── terraform-compliance/ # Compliance testing with Terraform
│       │   └── terraform-compliance.yml
│       └── audit-tools/      # Tools for auditing configurations
│           └── audit-configs.yml
│
├── docs/                     # Project documentation
│   ├── architecture.md       # High-level architecture overview
│   ├── modules.md            # Documentation for modules
│   ├── variables.md          # Documentation for variables
│   ├── best-practices.md     # Best practices for using Terraform
│   ├── compliance.md         # Compliance and security requirements
│   ├── troubleshooting.md    # Troubleshooting guide
│   ├── integration.md        # Documentation for tool integrations
│   ├── governance.md         # Documentation on governance policies
│   └── multi-cloud.md        # Documentation for multi-cloud setups
│
├── .terraform/               # Directory created by Terraform for plugin management
│
├── .gitignore                 # Git ignore file to exclude specific files
├── .terraform-version         # Specify the version of Terraform used
├── .env                      # Environment variables (optional)
├── .prettierignore            # Prettier ignore file for formatting (if used)
├── .prettierrc                # Prettier configuration file (if used)
└── README.md                 # Project documentation
```

### Key Components and Details

#### **1. Modules**
- **Network, Compute, Storage, Security, Monitoring, Application**: Reusable modules to manage infrastructure components, each with its own `main.tf`, `variables.tf`, `outputs.tf`, and testing setup.
- **Multi-Cloud Modules**: Separate modules for AWS, Azure, and GCP to handle cloud-specific resources.

#### **2. Environments**
- **Dev, Staging, Production**: Configurations for different environments, each with its own Terraform files

 to handle specific requirements.

#### **3. Terraform Configurations**
- **Provider, Backend, Variables, Outputs**: General configurations used across all environments, including backend settings and global variables.

#### **4. Scripts**
- **Automation Scripts**: Scripts to manage setup, deployment, validation, and backups. Useful for automating routine tasks and ensuring consistency.

#### **5. Tools**
- **Linting, Security Scanning, CI/CD, Compliance**: Configurations for integrating various tools for code quality, security checks, continuous integration/deployment, and compliance.

#### **6. Documentation**
- **Architecture, Modules, Best Practices, Compliance**: Detailed documentation to support understanding, usage, and maintenance of the Terraform project.

### Considerations for Enterprise Projects

- **Governance and Compliance**: Implementing policies for code review, change management, and compliance checks to adhere to organizational standards and regulations.
- **Multi-Cloud Strategy**: Managing resources across multiple cloud providers with specific modules for each, facilitating interoperability and avoiding vendor lock-in.
- **CI/CD Integration**: Automating Terraform workflows with CI/CD pipelines to enable continuous integration and deployment of infrastructure changes.
- **Security and Compliance**: Implementing security scanning tools, compliance checks, and best practices for managing sensitive data and adhering to security standards.
- **Documentation and Training**: Providing thorough documentation and training materials to support teams in using and managing Terraform configurations effectively.

This structure aims to support scalability, security, and maintainability in complex enterprise environments.
